
 /**
  * This template file was generated by dynaTrace client.
  * The dynaTrace community portal can be found here: http://community.dynatrace.com/
  * For information how to publish a plugin please visit http://community.dynatrace.com/plugins/contribute/
  **/ 

package com.dynatrace.diagnostic.plugins;

import com.dynatrace.diagnostics.pdk.*;

import java.util.Collection;
import java.util.HashMap;
import java.util.Set;
import java.util.logging.Logger;

public class MessageFlowStatisticsMonitor implements Monitor {

	public String METRIC_MESSAGE_FLOW_GROUP = "Message Flow Group";
	private String PARAM_QMGR_PORT="qMgr.port";
	private String PARAM_QMGR_NAME="qMgr.name";
	private String PARAM_QMGR_SERVER_CHANNEL = "qMgr.channel";
	private String PARAM_STATS_TOPIC="qMgr.topic";
	private int port;
	private String host;
	private String user;
	private String passwd;
	private String queueManagerName;
	private String queueManagerChannel;
	private String statsTopic;
	private static final Logger log = Logger.getLogger(MessageFlowStatisticsMonitor.class.getName());
	private static Thread dcThread;
	public static Object LOCK = new Object();
	public DataCollectionThread DCThread;
	
	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this
	 * scheduled Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link Plugin#teardown() teardown()} will be called
	 * next.
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * @param env
	 *            the configured <tt>MonitorEnvironment</tt> for this Plugin;
	 *            contains subscribed measures, but <b>measurements will be
	 *            discarded</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
		synchronized(LOCK) {
		host = (env.getHost().getAddress() == null) ? "localhost" : env.getHost().getAddress();
		port = (env.getConfigString(PARAM_QMGR_PORT) == null) ? 1414 : Integer.parseInt(env.getConfigString(PARAM_QMGR_PORT));
		queueManagerName = env.getConfigString(PARAM_QMGR_NAME);
		queueManagerChannel = env.getConfigString(PARAM_QMGR_SERVER_CHANNEL);
		statsTopic = env.getConfigString(PARAM_STATS_TOPIC);

		if ( queueManagerName == null || queueManagerChannel == null || statsTopic == null) {
			return new Status(Status.StatusCode.ErrorInternalConfigurationProblem, "All required parameters are not defined");
		}

		boolean authenticate = env.getConfigBoolean("qmgr.authenticate").booleanValue();
		user = null;
		passwd=null;
		if (authenticate) {
			user = env.getConfigString("qmgr.userId");

			if ( user == null) {
				return new Status(Status.StatusCode.ErrorInternalConfigurationProblem, "User Id not defined.");
			}

			passwd = env.getConfigPassword("authenticate.passwd");
		}
		
		try {
			init();
		}
		catch (Exception e) {
			log.severe(e.getMessage());
			return new Status(Status.StatusCode.ErrorInfrastructureUnreachable, e.getMessage());
		}
        return new Status(Status.StatusCode.Success);
	}
	}

	private void init() throws Exception {
		synchronized(LOCK) { 
		DCThread = new DataCollectionThread();
		DCThread.setHost(host);
		DCThread.setPort(port);
		DCThread.setQMgrName(queueManagerName);
		DCThread.setServerChannel(queueManagerChannel);
		DCThread.setStatsTopic(statsTopic);

		if ( user != null) {
			DCThread.setUserId(user);
		}

		if (passwd != null) {
			DCThread.setPasswd(passwd);
		}
		DCThread.setGathering(true);

		try {
			DCThread.setup();
			dcThread = new Thread(DCThread);
			dcThread.start();
		}
		catch (Exception e) {
			log.severe(e.getLocalizedMessage());
			throw new Exception("Cause="+e.getCause() + " Message="+ e.getMessage());
		}
		}

	}
	
	/**
	 * Executes the Monitor Plugin to retrieve subscribed measures and store
	 * measurements.
	 *
	 * <p>
	 * This method is called at the scheduled intervals. If the Plugin execution
	 * takes longer than the schedule interval, subsequent calls to
	 * {@link #execute(MonitorEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 *
	 * @param env
	 *            a <tt>MonitorEnvironment</tt> object that contains the
	 *            Plugin configuration and subscribed measures. These
	*            <tt>MonitorMeasure</tt>s can be used to store measurements.
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status execute(MonitorEnvironment env) throws Exception {
		String messageFlowName = env.getHost().getAddress();
		if ( DCThread.getExceptionOccurred()) {
			log.severe(messageFlowName);
			log.severe("Exception happened in dtc. Re-init.");
			try {
				init();
			}
			catch (Exception e) {
				log.severe(e.getMessage());
				return new Status(Status.StatusCode.ErrorInfrastructureUnreachable, e.getMessage());
			}
		}
//		HashMap<String, Long> statistics = DataCollectionThread.getMessageFlowData(messageFlowName);

		populateDT(env);
		
		return new Status(Status.StatusCode.Success);
	}

	  public void populateDT(MonitorEnvironment env) {
		  FlowStatElements[] flowStatElements = FlowStatElements.values();
		  HashMap<String, HashMap<String, Long>> messageFlowMap = DCThread.getMessageFlowMap();
		  //log.severe("Map size=" + messageFlowMap.size());
		  for (int p = 0; p < flowStatElements.length; p++) {
			  FlowStatElements flowStatElement = flowStatElements[p];
			  String metricKey = flowStatElement.getKey();
			  Set<String> keySet = messageFlowMap.keySet();
			  for (String messageFlowName: keySet) {
				  //log.info("Metric=" + metricKey + " flowName=" + messageFlowName);
				  Collection<MonitorMeasure> monitorMeasures = env.getMonitorMeasures("Message Flow Group", metricKey);
				  HashMap<String, Long> statistics = messageFlowMap.get(messageFlowName);
				  for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures) {
					  MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Message Flow Name", messageFlowName);
					  //measure conversion to microseconds here if contains _TIME? * 0.001
					  dynamicMeasure.setValue(statistics.get(metricKey));
				  }
			  }
		  }
	  }

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 *
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and
	 * <tt>teardown</tt> are called on different threads, but they are called
	 * sequentially. This means that the execution of these methods does not
	 * overlap, they are executed one after the other.
	 *
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt>
	 * ends -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout,
	 * <tt>execute</tt> stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is
	 * removed -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 *
	 *
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 *
	 * @see Monitor#setup(MonitorEnvironment)
	 */	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		 synchronized(LOCK) {
			 if ( DCThread.getGathering()) {
				 DCThread.setGathering(false);
				 Thread.sleep(1000);
				 DCThread.shutdown();
			 }
		 }
	}
	 
	 public void main(String args[]) {
		 synchronized(LOCK) {
			 DCThread.setHost(args[0]);
			 DCThread.setPort(Integer.parseInt(args[1]));
			 DCThread.setQMgrName(args[2]);
			 DCThread.setServerChannel(args[3]);
			 DCThread.setStatsTopic(args[4]);

		if ( args.length > 5 ) {
			DCThread.setUserId(args[5]);
		}
		DCThread.setGathering(true);

        try {
        	DCThread.setup();
        	Thread dct = new Thread(DCThread);
        	dct.start();
        }
        catch (Exception e) {
        	e.printStackTrace();
        }
	 }
	 }
}
